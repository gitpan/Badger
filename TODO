Badger::Class
-------------

* Have DEBUG generate constant DEBUG subroutine fixed to value of flag
  (or pre-defined $DEBUG variable if possible).  Unlike $DEBUG which is 
  evaluated at runtime and thus, is dynamic, the DEBUG constant subroutine
  would be statically resolved at compile time.  Slightly different usage,
  but worthwhile.
  
* finish cleanup and documentation

* AUTOLOAD method to delegate to real class if possible?

* fix up id() / base_id() to do something better

* make debug hook work better: allow import of other items, e.g.
  debug => ':dump'.  Also generate DEBUG constant using any existing
  value of $DEBUG.

* Document hooks() method and hook.  Create new section on subclassing
  Badger::Class
  
* add 'hook' subroutine attribute

* add a way for B::C subclasses to register hooks that automatically
  get called on import, e.g. for B::Factory::Class to push base()

* Remove class($class, $target) second argument in export hooks
  because UBER should now handle that - needs testing

* Make CLASS static


Badger::Codec
--------------

* encoded()/decoded() methods (e.g. for utf8)

* update docs to clarify the fact that utf8, etc., are available as named
  codecs via Encode/Encoding modules.


Badger::Debug
-------------

* See if we can make this a low-level mixin that we can import into 
  Badger::Utils et al.

Badger::Config
--------------

* Just a basic implementation at moment.  Merge in TT3 config, AppConfig
  and other stuff.


Badger::Docs
------------

* Finish writing it so we can build the web site.


Badger::Exception
-----------------

* needs good cleanup


Badger::Factory
---------------

* Split post-find operations into separate methods (and lower case).  
   e.g. find_ref_array(), find_ref_hash()
   
* Hmmm... maybe don't lower case but do sanitise, e.g. 
  find_ref_ARRAY(), find_ref_Your_Module() vs
  find_ref_array(), find_ref_your_module()

* Subclass out into base class (returns loaded module name), object
  creator, object creator + cache (e.g. for hub), or whatever.

Badger::Filesystem
------------------

* finish documentation - move VFS docs out of B::FS into B::FS::Virtual

* directory files/directories/dirs as grep across children

* virtual filesystems composed across several real filesystems

* need to handle encoding better in read_file() and write_file() methods.

* read-only filesystem option

* write_file() should have an option for writing to a temporary file and
  renaming into place to avoid race conditions.


Badger::Storage
---------------

* This is available in subversion but not yet included in the released
  distribution.

* unify parameter parsing and identity definition between filesystem and
  database storage modules.

* get/put which take data / return id

* fetch/store which returns 

* create/destroy   connect/disconnect  open/close


Badger::Test
------------

* Could do with some proper testing.  Although all the other test scripts
  do tend to thrash it quite well...


Badger::Utils
-------------

* make methods exportable subroutines

* maybe_load_module can be done using try() (although that requires us to
  call a class method.

* look into merging load_module() with Badger::Class::_autoload

Badger::Factory
---------------

* have it bind fetch methods to item/items if undefined, e.g
  node => item, nodes => items.

* support multi-element names, e.g. node.foo.bar


BadgerX
-------

* add path to any bases missing it

* document



Longer Terms Goals / Larger Projects
------------------------------------

* incorporate re-write of AppConfig into Badger::Config

* consider doing the same with Pod::POM into Badger::Pod and combining
  with Badger::Docs.  (update: doing now)

* Finish cleaning Badger-Web and release

* Finish refactoring Badger-Database and release



docs
----
links sections
Badger::Factory
